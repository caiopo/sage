schema {
  mutation: RootMutationType
  query: RootQueryType
}

type RegisterWithPasswordMetadata {
  "A JWT which the user can use to authenticate to the API."
  token: String!
}

"The result of the :register_with_password mutation"
type RegisterWithPasswordResult {
  "The successful result of the mutation"
  result: User

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]

  "Metadata produced by the mutation"
  metadata: RegisterWithPasswordMetadata
}

input RegisterWithPasswordInput {
  email: String!

  name: String!

  "The proposed password for the user, in plain text."
  password: String!

  "The proposed password for the user (again), in plain text."
  passwordConfirmation: String!
}

input UserFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UserFilterEmail {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UserFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  not: [UserFilterInput!]
  id: UserFilterId
  email: UserFilterEmail
  name: UserFilterName
}

type UserWithToken {
  id: ID!

  email: String!

  name: String!

  "A JWT which the user can use to authenticate to the API."
  token: String!
}

type User {
  id: ID!
  email: String!
  name: String!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

enum QuestionAnswerSortField {
  ID
  VALUE
  QUESTION_ID
}

input QuestionAnswerFilterQuestionId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionAnswerFilterValue {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input QuestionAnswerFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionAnswerFilterInput {
  and: [QuestionAnswerFilterInput!]
  or: [QuestionAnswerFilterInput!]
  not: [QuestionAnswerFilterInput!]
  id: QuestionAnswerFilterId
  value: QuestionAnswerFilterValue
  questionId: QuestionAnswerFilterQuestionId
  surveyAnswer: SurveyAnswerFilterInput
  question: QuestionFilterInput
}

input QuestionAnswerSortInput {
  order: SortOrder
  field: QuestionAnswerSortField!
}

type QuestionAnswer {
  id: ID!
  value: String
  questionId: ID!
  surveyAnswer: SurveyAnswer!
  question: Question!
}

"The result of the :archive_answer mutation"
type ArchiveAnswerResult {
  "The record that was successfully deleted"
  result: SurveyAnswer

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :create_answer mutation"
type CreateAnswerResult {
  "The successful result of the mutation"
  result: SurveyAnswer

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateAnswerInput {
  questionAnswers: [SurveyAnswerCreateQuestionAnswersInput!]
}

input SurveyAnswerCreateQuestionAnswersInput {
  value: String
  questionId: ID!
}

enum SurveyAnswerSortField {
  ID
}

input SurveyAnswerFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyAnswerFilterInput {
  and: [SurveyAnswerFilterInput!]
  or: [SurveyAnswerFilterInput!]
  not: [SurveyAnswerFilterInput!]
  id: SurveyAnswerFilterId
  survey: SurveyFilterInput
  questionAnswers: QuestionAnswerFilterInput
}

input SurveyAnswerSortInput {
  order: SortOrder
  field: SurveyAnswerSortField!
}

type SurveyAnswer {
  id: ID!
  survey: Survey
  questionAnswers(
    "How to sort the records in the response"
    sort: [QuestionAnswerSortInput]

    "A filter to limit the results"
    filter: QuestionAnswerFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [QuestionAnswer!]!
}

enum QuestionType {
  SINGLE
  MULTI
  TEXT
  NUMBER
}

enum QuestionSortField {
  ID
  TITLE
  DESCRIPTION
  REQUIRED
  ATTRIBUTES
  TYPE
}

input QuestionFilterType {
  isNil: Boolean
  eq: QuestionType
  notEq: QuestionType
  in: [QuestionType!]
  lessThan: QuestionType
  greaterThan: QuestionType
  lessThanOrEqual: QuestionType
  greaterThanOrEqual: QuestionType
}

input QuestionFilterAttributes {
  isNil: Boolean
  eq: Json
  notEq: Json
  in: [Json!]
  lessThan: Json
  greaterThan: Json
  lessThanOrEqual: Json
  greaterThanOrEqual: Json
}

input QuestionFilterRequired {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input QuestionFilterDescription {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input QuestionFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input QuestionFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionFilterInput {
  and: [QuestionFilterInput!]
  or: [QuestionFilterInput!]
  not: [QuestionFilterInput!]
  id: QuestionFilterId
  title: QuestionFilterTitle
  description: QuestionFilterDescription
  required: QuestionFilterRequired
  attributes: QuestionFilterAttributes
  type: QuestionFilterType
}

input QuestionSortInput {
  order: SortOrder
  field: QuestionSortField!
}

type Question {
  id: ID!
  title: String!
  description: String!
  required: Boolean!
  attributes: Json!
  type: QuestionType!
}

"The result of the :archive_survey mutation"
type ArchiveSurveyResult {
  "The record that was successfully deleted"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :update_survey mutation"
type UpdateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input UpdateSurveyInput {
  title: String
  questions: [SurveyUpdateQuestionsInput!]
}

"The result of the :create_survey mutation"
type CreateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateSurveyInput {
  title: String!
  questions: [SurveyCreateQuestionsInput!]
}

input SurveyUpdateQuestionsInput {
  attributes: Json
  id: ID
  type: QuestionType
  description: String
  title: String
  required: Boolean
}

input SurveyCreateQuestionsInput {
  attributes: Json
  id: ID
  type: QuestionType
  description: String
  title: String
  required: Boolean
}

enum SurveySortField {
  ID
  TITLE
}

input SurveyFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SurveyFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyFilterInput {
  and: [SurveyFilterInput!]
  or: [SurveyFilterInput!]
  not: [SurveyFilterInput!]
  id: SurveyFilterId
  title: SurveyFilterTitle
  owner: UserFilterInput
  questions: QuestionFilterInput
}

input SurveySortInput {
  order: SortOrder
  field: SurveySortField!
}

type Survey {
  id: ID!
  title: String!
  owner: User!
  questions(
    "How to sort the records in the response"
    sort: [QuestionSortInput]

    "A filter to limit the results"
    filter: QuestionFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Question!]!
}

type RootQueryType {
  getSurvey(
    "The id of the record"
    id: ID!
  ): Survey
  listSurveys(
    "How to sort the records in the response"
    sort: [SurveySortInput]

    "A filter to limit the results"
    filter: SurveyFilterInput
  ): [Survey!]!
  getAnswer(
    "The id of the record"
    id: ID!
  ): SurveyAnswer
  listAnswers(
    "How to sort the records in the response"
    sort: [SurveyAnswerSortInput]

    "A filter to limit the results"
    filter: SurveyAnswerFilterInput
  ): [SurveyAnswer!]!
}

type RootMutationType {
  createSurvey(input: CreateSurveyInput!): CreateSurveyResult!

  updateSurvey(id: ID!, input: UpdateSurveyInput): UpdateSurveyResult!

  archiveSurvey(id: ID!): ArchiveSurveyResult!

  createAnswer(input: CreateAnswerInput): CreateAnswerResult!

  archiveAnswer(id: ID!): ArchiveAnswerResult!

  "Register a new user with a username and password."
  registerWithPassword(input: RegisterWithPasswordInput!): RegisterWithPasswordResult!

  "Attempt to sign in using a username and password."
  signInWithPassword(
    "The identity to use for retrieving the user."
    email: String!

    "The password to check for the matching user."
    password: String!
  ): UserWithToken
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json
