schema {
  mutation: RootMutationType
  query: RootQueryType
}

enum QuestionType {
  SINGLE
  MULTI
  TEXT
  NUMBER
}

input UpdateSurveyInput {
  title: String
  questions: [UpdateQuestionsInput!]
}

type Question {
  id: ID!
  title: String!
  type: QuestionType!
}

input CreateSurveyInput {
  title: String!
  questions: [CreateQuestionsInput!]
}

type Survey {
  id: ID!
  title: String!
  owner: User!
  questions(
    "How to sort the records in the response"
    sort: [QuestionSortInput]

    "A filter to limit the results"
    filter: QuestionFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Question!]!
}

input QuestionSortInput {
  order: SortOrder
  field: QuestionSortField!
}

type User {
  id: ID!
  email: String!
  name: String!
}

input UserFilterEmail {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input UserFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input RegisterWithPasswordInput {
  email: String!
  name: String!
  password: String!
  passwordConfirmation: String!
}

input SurveyFilterInput {
  and: [SurveyFilterInput!]
  or: [SurveyFilterInput!]
  id: SurveyFilterId
  title: SurveyFilterTitle
  owner: UserFilterInput
  questions: QuestionFilterInput
}

type RootQueryType {
  getSurvey(
    "The id of the record"
    id: ID!
  ): Survey
  listSurveys(
    "How to sort the records in the response"
    sort: [SurveySortInput]

    "A filter to limit the results"
    filter: SurveyFilterInput
  ): [Survey!]!
}

input SurveySortInput {
  order: SortOrder
  field: SurveySortField!
}

input CreateQuestionsInput {
  id: ID
  title: String
  type: QuestionType
}

input QuestionFilterInput {
  and: [QuestionFilterInput!]
  or: [QuestionFilterInput!]
  id: QuestionFilterId
  title: QuestionFilterTitle
  type: QuestionFilterType
}

input QuestionFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

type UserWithToken {
  id: ID!

  email: String!

  name: String!

  "A JWT which the user can use to authenticate to the API."
  token: String!
}

input SurveyFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input UpdateQuestionsInput {
  id: ID
  title: String
  type: QuestionType
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  id: UserFilterId
  email: UserFilterEmail
  name: UserFilterName
}

input QuestionFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

enum SurveySortField {
  ID
  TITLE
}

"The result of the :update_survey mutation"
type UpdateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

input UserFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String]
}

enum SortOrder {
  DESC
  ASC
}

input SurveyFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

type RegisterWithPasswordMetadata {
  "A JWT which the user can use to authenticate to the API."
  token: String!
}

"The result of the :register_with_password mutation"
type RegisterWithPasswordResult {
  "The successful result of the mutation"
  result: User

  "Any errors generated, if the mutation failed"
  errors: [MutationError]

  "Metadata produced by the mutation"
  metadata: RegisterWithPasswordMetadata
}

input QuestionFilterType {
  isNil: Boolean
  eq: QuestionType
  notEq: QuestionType
  in: [QuestionType!]
  lessThan: QuestionType
  greaterThan: QuestionType
  lessThanOrEqual: QuestionType
  greaterThanOrEqual: QuestionType
}

"The result of the :archive_survey mutation"
type ArchiveSurveyResult {
  "The record that was successfully deleted"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}

enum QuestionSortField {
  ID
  TITLE
  TYPE
}

type RootMutationType {
  createSurvey(input: CreateSurveyInput): CreateSurveyResult
  updateSurvey(id: ID, input: UpdateSurveyInput): UpdateSurveyResult
  archiveSurvey(id: ID): ArchiveSurveyResult
  registerWithPassword(input: RegisterWithPasswordInput): RegisterWithPasswordResult
  signInWithPassword(email: String!, password: String!): UserWithToken
}

"The result of the :create_survey mutation"
type CreateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}
