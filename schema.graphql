schema {
  mutation: RootMutationType
  query: RootQueryType
}

type RegisterWithPasswordMetadata {
  "A JWT which the user can use to authenticate to the API."
  token: String!
}

"The result of the :register_with_password mutation"
type RegisterWithPasswordResult {
  "The successful result of the mutation"
  result: User

  "Any errors generated, if the mutation failed"
  errors: [MutationError]

  "Metadata produced by the mutation"
  metadata: RegisterWithPasswordMetadata
}

input RegisterWithPasswordInput {
  email: String!

  name: String!

  "The proposed password for the user, in plain text."
  password: String!

  "The proposed password for the user (again), in plain text."
  passwordConfirmation: String!
}

input UserFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input UserFilterEmail {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input UserFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  not: [UserFilterInput!]
  id: UserFilterId
  email: UserFilterEmail
  name: UserFilterName
}

type UserWithToken {
  id: ID!

  email: String!

  name: String!

  "A JWT which the user can use to authenticate to the API."
  token: String!
}

type User {
  id: ID!
  email: String!
  name: String!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String]
}

enum QuestionType {
  SINGLE
  MULTI
  TEXT
  NUMBER
}

enum QuestionSortField {
  ID
  TITLE
  DESCRIPTION
  REQUIRED
  ATTRIBUTES
  TYPE
}

input QuestionFilterType {
  isNil: Boolean
  eq: QuestionType
  notEq: QuestionType
  in: [QuestionType!]
  lessThan: QuestionType
  greaterThan: QuestionType
  lessThanOrEqual: QuestionType
  greaterThanOrEqual: QuestionType
}

input QuestionFilterAttributes {
  isNil: Boolean
  eq: JsonString
  notEq: JsonString
  in: [JsonString!]
  lessThan: JsonString
  greaterThan: JsonString
  lessThanOrEqual: JsonString
  greaterThanOrEqual: JsonString
}

input QuestionFilterRequired {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input QuestionFilterDescription {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input QuestionFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input QuestionFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionFilterInput {
  and: [QuestionFilterInput!]
  or: [QuestionFilterInput!]
  not: [QuestionFilterInput!]
  id: QuestionFilterId
  title: QuestionFilterTitle
  description: QuestionFilterDescription
  required: QuestionFilterRequired
  attributes: QuestionFilterAttributes
  type: QuestionFilterType
}

input QuestionSortInput {
  order: SortOrder
  field: QuestionSortField!
}

type Question {
  id: ID!
  title: String!
  description: String!
  required: Boolean!
  attributes: JsonString!
  type: QuestionType!
}

"The result of the :archive_survey mutation"
type ArchiveSurveyResult {
  "The record that was successfully deleted"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}

"The result of the :update_survey mutation"
type UpdateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}

input UpdateSurveyInput {
  title: String
  questions: [SurveyUpdateQuestionsInput!]
}

"The result of the :create_survey mutation"
type CreateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError]
}

input CreateSurveyInput {
  title: String!
  questions: [SurveyCreateQuestionsInput!]
}

input SurveyUpdateQuestionsInput {
  attributes: JsonString
  id: ID
  type: QuestionType
  description: String
  title: String
  required: Boolean
}

input SurveyCreateQuestionsInput {
  attributes: JsonString
  id: ID
  type: QuestionType
  description: String
  title: String
  required: Boolean
}

enum SurveySortField {
  ID
  TITLE
}

input SurveyFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input SurveyFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyFilterInput {
  and: [SurveyFilterInput!]
  or: [SurveyFilterInput!]
  not: [SurveyFilterInput!]
  id: SurveyFilterId
  title: SurveyFilterTitle
  owner: UserFilterInput
  questions: QuestionFilterInput
}

input SurveySortInput {
  order: SortOrder
  field: SurveySortField!
}

type Survey {
  id: ID!
  title: String!
  owner: User!
  questions(
    "How to sort the records in the response"
    sort: [QuestionSortInput]

    "A filter to limit the results"
    filter: QuestionFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Question!]!
}

type RootQueryType {
  getSurvey(
    "The id of the record"
    id: ID!
  ): Survey
  listSurveys(
    "How to sort the records in the response"
    sort: [SurveySortInput]

    "A filter to limit the results"
    filter: SurveyFilterInput
  ): [Survey!]!
}

type RootMutationType {
  createSurvey(input: CreateSurveyInput): CreateSurveyResult

  updateSurvey(id: ID, input: UpdateSurveyInput): UpdateSurveyResult

  archiveSurvey(id: ID): ArchiveSurveyResult

  "Register a new user with a username and password."
  registerWithPassword(input: RegisterWithPasswordInput): RegisterWithPasswordResult

  "Attempt to sign in using a username and password."
  signInWithPassword(
    "The identity to use for retrieving the user."
    email: String!

    "The password to check for the matching user."
    password: String!
  ): UserWithToken
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar JsonString

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json
