schema {
  mutation: RootMutationType
  query: RootQueryType
}

type RegisterWithPasswordMetadata {
  "A JWT which the user can use to authenticate to the API."
  token: String!
}

"The result of the :register_with_password mutation"
type RegisterWithPasswordResult {
  "The successful result of the mutation"
  result: User

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]

  "Metadata produced by the mutation"
  metadata: RegisterWithPasswordMetadata
}

input RegisterWithPasswordInput {
  email: String!

  name: String!

  "The proposed password for the user, in plain text."
  password: String!

  "The proposed password for the user (again), in plain text."
  passwordConfirmation: String!
}

type UserWithToken {
  id: ID!

  email: String!

  name: String!

  "A JWT which the user can use to authenticate to the API."
  token: String!
}

type User {
  id: ID!
  email: String!
  name: String!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

enum QuestionAnswerSortField {
  ID
  VALUE
  SURVEY_ANSWER_ID
  QUESTION_ID
}

input QuestionAnswerFilterQuestionId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionAnswerFilterSurveyAnswerId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionAnswerFilterValue {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input QuestionAnswerFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionAnswerFilterInput {
  and: [QuestionAnswerFilterInput!]
  or: [QuestionAnswerFilterInput!]
  not: [QuestionAnswerFilterInput!]
  id: QuestionAnswerFilterId
  value: QuestionAnswerFilterValue
  surveyAnswerId: QuestionAnswerFilterSurveyAnswerId
  questionId: QuestionAnswerFilterQuestionId
  surveyAnswer: SurveyAnswerFilterInput
  question: QuestionFilterInput
}

input QuestionAnswerSortInput {
  order: SortOrder
  field: QuestionAnswerSortField!
}

type QuestionAnswer {
  id: ID!
  value: String
  surveyAnswerId: ID!
  questionId: ID!
  surveyAnswer: SurveyAnswer!
  question: Question!
}

"The result of the :archive_answer mutation"
type ArchiveAnswerResult {
  "The record that was successfully deleted"
  result: SurveyAnswer

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :create_answer mutation"
type CreateAnswerResult {
  "The successful result of the mutation"
  result: SurveyAnswer

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateAnswerInput {
  questionAnswers: [SurveyAnswerCreateQuestionAnswersInput!]
}

input SurveyAnswerCreateQuestionAnswersInput {
  id: ID
}

enum SurveyAnswerSortField {
  ID
  SURVEY_ID
}

"A keyset page of :survey_answer"
type KeysetPageOfSurveyAnswer {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [SurveyAnswer!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input SurveyAnswerFilterSurveyId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyAnswerFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyAnswerFilterInput {
  and: [SurveyAnswerFilterInput!]
  or: [SurveyAnswerFilterInput!]
  not: [SurveyAnswerFilterInput!]
  id: SurveyAnswerFilterId
  surveyId: SurveyAnswerFilterSurveyId
  survey: SurveyFilterInput
  questionAnswers: QuestionAnswerFilterInput
}

input SurveyAnswerSortInput {
  order: SortOrder
  field: SurveyAnswerSortField!
}

type SurveyAnswer {
  id: ID!
  surveyId: ID
  survey: Survey
  questionAnswers(
    "How to sort the records in the response"
    sort: [QuestionAnswerSortInput]

    "A filter to limit the results"
    filter: QuestionAnswerFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [QuestionAnswer!]!
}

input QuestionFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input QuestionFilterInput {
  and: [QuestionFilterInput!]
  or: [QuestionFilterInput!]
  not: [QuestionFilterInput!]
  id: QuestionFilterId
}

type Question {
  id: ID!
}

"The result of the :archive_survey mutation"
type ArchiveSurveyResult {
  "The record that was successfully deleted"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :update_survey mutation"
type UpdateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input UpdateSurveyInput {
  questions: [SurveyUpdateQuestionsInput!]
}

"The result of the :create_survey mutation"
type CreateSurveyResult {
  "The successful result of the mutation"
  result: Survey

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateSurveyInput {
  questions: [SurveyCreateQuestionsInput!]
}

input SurveyUpdateQuestionsInput {
  id: ID
}

input SurveyCreateQuestionsInput {
  id: ID
}

enum SurveySortField {
  ID
  TITLE
}

"A keyset page of :survey"
type KeysetPageOfSurvey {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [Survey!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input SurveyFilterTitle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SurveyFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input SurveyFilterInput {
  and: [SurveyFilterInput!]
  or: [SurveyFilterInput!]
  not: [SurveyFilterInput!]
  id: SurveyFilterId
  title: SurveyFilterTitle
}

input SurveySortInput {
  order: SortOrder
  field: SurveySortField!
}

type Survey {
  id: ID!
  title: String!
}

type RootQueryType {
  getSurvey(
    "The id of the record"
    id: ID!
  ): Survey
  listSurveys(
    "How to sort the records in the response"
    sort: [SurveySortInput]

    "A filter to limit the results"
    filter: SurveyFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfSurvey
  getAnswer(
    "The id of the record"
    id: ID!
  ): SurveyAnswer
  listAnswers(
    "How to sort the records in the response"
    sort: [SurveyAnswerSortInput]

    "A filter to limit the results"
    filter: SurveyAnswerFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfSurveyAnswer
}

type RootMutationType {
  createSurvey(input: CreateSurveyInput): CreateSurveyResult!

  updateSurvey(id: ID!, input: UpdateSurveyInput): UpdateSurveyResult!

  archiveSurvey(id: ID!): ArchiveSurveyResult!

  createAnswer(input: CreateAnswerInput): CreateAnswerResult!

  archiveAnswer(id: ID!): ArchiveAnswerResult!

  "Register a new user with a username and password."
  registerWithPassword(input: RegisterWithPasswordInput!): RegisterWithPasswordResult!

  "Attempt to sign in using a username and password."
  signInWithPassword(
    "The identity to use for retrieving the user."
    email: String!

    "The password to check for the matching user."
    password: String!
  ): UserWithToken
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json
